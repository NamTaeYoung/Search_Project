diff a/backend/src/main/java/com/boot/controller/StockController.java b/backend/src/main/java/com/boot/controller/StockController.java	(rejected hunks)
@@ -120,7 +120,58 @@
     }
 
     public static class StockData {
-        public String code;
-        public String currentPrice;
+        public String code;          // 종목코드
+        public String currentPrice;  // 현재가
+        public String priceChange;   // 전일대비
+        public String changeRate;    // 등락률
     }
+
+    @PostMapping("/subscribe/{code}")
+    public ResponseEntity<Void> subscribe(@PathVariable String code) {
+
+        String pythonUrl = "http://localhost:5000/subscribe";
+
+        Map<String, String> body = new HashMap<>();
+        body.put("code", code);
+
+        HttpHeaders headers = new HttpHeaders();
+        headers.setContentType(MediaType.APPLICATION_JSON);
+
+        HttpEntity<Map<String, String>> entity = new HttpEntity<>(body, headers);
+
+        // 구독은 RestTemplate (동기) 사용
+        restTemplate.postForObject(pythonUrl, entity, String.class);
+//        System.out.println("Python Unsubscribe 요청 성공: " + code);
+
+        return ResponseEntity.ok().build();
+    }
+
+
+    @PostMapping("/unsubscribe/{code}")
+    public ResponseEntity<Void> unsubscribe(@PathVariable String code) {
+
+        String pythonUrl = "/unsubscribe"; // WebClient의 baseUrl을 사용하도록 Path만 남깁니다.
+
+        Map<String, String> body = new HashMap<>();
+        body.put("code", code);
+
+        // WebClient를 사용하여 비동기적으로 요청을 보내고 결과를 기다리지 않습니다.
+        // 이는 React의 sendBeacon 요청이 끊겨도 백그라운드에서 요청을 완료하도록 보장합니다.
+        webClient.post()
+            .uri(pythonUrl)
+            .contentType(MediaType.APPLICATION_JSON)
+            .bodyValue(body)
+            .retrieve()
+            .toBodilessEntity()
+            .subscribe(
+                success -> System.out.println("Python Unsubscribe 요청 성공: " + code),
+                error -> System.err.println("Python Unsubscribe 요청 실패: " + code + ", 에러: " + error.getMessage())
+            );
+        
+        // 클라이언트에게는 즉시 응답을 보냅니다.
+        return ResponseEntity.ok().build();
+    }
+
+
+
 }
